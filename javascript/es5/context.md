# 上下文

代码的执行环境

## 分类

* `global`: `JavaScript`一开始进入的全局上下文
* `function`: `JavaScript`调用函数时进入函数上下文
* `eval`: `JavaScript`调用`eval`进入`eval`上下文，严格模式下与`function`相似

## 执行过程

* 进入上下文并将上下文对象压入堆栈
* 初始化上下文
* 执行上下文代码
* 退出堆栈

## 上下文对象

即作用域

* `global`: 全局对象，内置全局属性和全局方法，原型对象为`Object.prototype`
* `function`: 活动对象，内置`arguments`数组和形参，原型对象为`null`
* `eval`: `eval`作用域
  * 直接调用(`eval(...)`)，为`eval`作用域
  * 间接使用(其他)，为全局作用域

作用域链

* 作用域之间的父子关系构成作用域链
* 查找标识符时，首先在当前作用域查找，再查找当前作用域的原型链，接着查找父作用域和父作用域的原型链，直到全局作用域和全局作用域的原型链为止

作用域变动

* 函数创建时，会静态存入所有父作用域
  * 使用`Function`构造函数创建的函数，只会静态存入全局作用域
  * 使用命名函数表达式创建的函数，会添加一个特殊对象`{fnName:<function>}`到作用域链的前端
* 函数调用时，会将函数上下文的活动对象添加到作用域的前端
* 执行`width`语句时，会将指定对象添加到作用域的前端
* 执行`catch`语句时，会将一个包含异常对象的对象添加到作用域的前端

## 初始化

* 初始化内置属性和方法
* 初始化变量
* 初始化this指针

### 初始化变量

解析上下文代码

* 添加函数声明，值为声明的函数，若存在，则替换
* 添加变量声明，值为undefined, 若存在，则略过

### 初始化this指针

* `global`: `this`为全局对象
* `function`: `this`取决于函数调用的方式
  * 单纯调用函数
    * 严格模式下为`undefined`
    * 非严格模式自动转换为全局对象
  * 调用对象方法，`this`为该对象
  * 调用构造函数，`this`为该实例对象
  * 调用`call()`, `apply()`方法
    * 严格模式下，为设置的值
    * 非严格模式下，`Undefined, Null`类型自动转换为全局对象，`Number, String, Boolean`类型自动转换为对应的包装对象

## 执行代码

* `同步`: 按顺序解释执行
* `异步`: 将异步代码交给其他线程执行，接着执行主线程后面的代码

> * 所有同步任务都在主线程上执行，形成一个执行栈
> * 主线程发起异步请求时，相应的工作线程就会去执行异步任务，主线程则继续执行后面的代码
> * 主线程之外，还存在一个"任务队列"，只要异步任务有了运行结果，就在"任务队列"之中放置一个消息。
> * 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，执行事件对应的回调。
> * 主线程把当前的事件执行完成之后,会再去读取任务队列,如此反复重复执行,就形成了事件循环

![执行代码](images/execute.png)

## 垃圾收集

找出不再继续使用的变量，并释放其占用的内存

### 算法

* 标记清除：离开作用域的值将被自动标记为可以回收，主流算法
* 引用计数：跟踪记录所有值被引用的次数，存在循环引用问题

### 内存管理

解除值的引用能让值脱离执行环境，以便垃圾收集器下次运行时将其回收